This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-17T05:51:03.999Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
project/
  app/
    main.py
    requirements.txt
    tts.py
  docker-compose.yml
  Dockerfile
setup.sh

================================================================
Repository Files
================================================================

================
File: project/app/main.py
================
from fastapi import FastAPI, HTTPException
from app.tts import get_tts

app = FastAPI()

@app.post("/tts")
async def generate_tts(text: str):
    """
    Accepts text input and returns the TTS audio file URL.
    """
    try:
        audio_url = await get_tts(text)
        return {"audio_url": audio_url}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

================
File: project/app/requirements.txt
================
fastapi
aiohttp
uvicorn

================
File: project/app/tts.py
================
import aiohttp
import uuid
import os

TTS_API_URL = "https://api.openai.com/v1/tts"  # 適切なTTSエンドポイントを使用

API_KEY = os.getenv("OPENAI_API_KEY")

async def get_tts(text: str) -> str:
    """
    Sends a request to the TTS service and returns the audio URL.
    """
    if not API_KEY:
        raise ValueError("API key for TTS is not set.")

    headers = {
        "Authorization": f"Bearer {API_KEY}",
        "Content-Type": "application/json"
    }

    payload = {
        "text": text,
        "voice": "en-US-Wavenet-D"  # 適宜選択
    }

    async with aiohttp.ClientSession() as session:
        async with session.post(TTS_API_URL, headers=headers, json=payload) as response:
            if response.status != 200:
                raise Exception(f"TTS API failed with status {response.status}")
            data = await response.json()

    # Save audio file locally or return URL
    file_name = f"{uuid.uuid4()}.mp3"
    file_path = f"static/{file_name}"

    with open(file_path, "wb") as f:
        f.write(data["audio_content"].encode("latin1"))  # 適宜エンコード調整

    return f"http://localhost:8000/static/{file_name}"

================
File: project/docker-compose.yml
================
version: "3.9"
services:
  app:
    build: .
    ports:
      - "8400:8400"
    volumes:
      - ./app:/usr/src/app
    environment:
      - OPENAI_API_KEY=your_openai_api_key

================
File: project/Dockerfile
================
# Use an official Python runtime as a parent image
FROM python:3.10-slim

# Set the working directory in the container
WORKDIR /usr/src/app

# Copy the application files into the container
COPY ./app /usr/src/app

# Install the dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Expose port 8400
EXPOSE 8400

# Command to run the application
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8400", "--reload"]

================
File: setup.sh
================
#!/bin/bash

# Create project directories and files
mkdir -p project/app
cd project

# Create main.py
cat > app/main.py <<EOL
from fastapi import FastAPI, HTTPException
from app.tts import get_tts

app = FastAPI()

@app.post("/tts")
async def generate_tts(text: str):
    """
    Accepts text input and returns the TTS audio file URL.
    """
    try:
        audio_url = await get_tts(text)
        return {"audio_url": audio_url}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
EOL

# Create tts.py
cat > app/tts.py <<EOL
import aiohttp
import uuid
import os

TTS_API_URL = "https://api.openai.com/v1/tts"  # 適切なTTSエンドポイントを使用

API_KEY = os.getenv("OPENAI_API_KEY")

async def get_tts(text: str) -> str:
    """
    Sends a request to the TTS service and returns the audio URL.
    """
    if not API_KEY:
        raise ValueError("API key for TTS is not set.")

    headers = {
        "Authorization": f"Bearer {API_KEY}",
        "Content-Type": "application/json"
    }

    payload = {
        "text": text,
        "voice": "en-US-Wavenet-D"  # 適宜選択
    }

    async with aiohttp.ClientSession() as session:
        async with session.post(TTS_API_URL, headers=headers, json=payload) as response:
            if response.status != 200:
                raise Exception(f"TTS API failed with status {response.status}")
            data = await response.json()

    # Save audio file locally or return URL
    file_name = f"{uuid.uuid4()}.mp3"
    file_path = f"static/{file_name}"

    with open(file_path, "wb") as f:
        f.write(data["audio_content"].encode("latin1"))  # 適宜エンコード調整

    return f"http://localhost:8000/static/{file_name}"
EOL

# Create requirements.txt
cat > app/requirements.txt <<EOL
fastapi
aiohttp
uvicorn
EOL

# Create Dockerfile
cat > Dockerfile <<EOL
# Use an official Python runtime as a parent image
FROM python:3.10-slim

# Set the working directory in the container
WORKDIR /usr/src/app

# Copy the application files into the container
COPY ./app /usr/src/app

# Install the dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Expose port 8400
EXPOSE 8400

# Command to run the application
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8400", "--reload"]
EOL

# Create docker-compose.yml
cat > docker-compose.yml <<EOL
version: "3.9"
services:
  app:
    build: .
    ports:
      - "8400:8400"
    volumes:
      - ./app:/usr/src/app
    environment:
      - OPENAI_API_KEY=your_openai_api_key
EOL

echo "Setup complete. Run 'docker-compose up --build' to start the service."
